0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07
)
boxplot(
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07
)
)
summary(
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07
)
)
summary(
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07-242
)
)
boxplot(
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07
),
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07-242
)
)
boxplot(
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07
),
c(
463.18,
423.86,
85.05,
0,
583.77,
542.82,
226.22,
437.37,
261.24,
862.84,
303.07-242,
303.07-242
)
)
?dist
a <- matrix(c(1,2))
a
a <- matrix(c(c(1,2),c(1,2)))
a
c(1:5)
as.matrix(c(1:5))
matrix(c(1:5))
matrix(data = c(1:4), nrow = 2, ncol = 2)
dist(matrix(data = c(1:4), nrow = 2, ncol = 2))
data.frame(dist(matrix(data = c(1:4), nrow = 2, ncol = 2)))
dist(matrix(data = c(1:4), nrow = 2, ncol = 2))
as.matrix(dist(matrix(data = c(1:4), nrow = 2, ncol = 2)))
?plot
?eigen
eigen(cbind(c(1,-1), c(-1,1)))
a <- eigen(cbind(c(1,-1), c(-1,1)))
################################################################################
# downloading packages
################################################################################
# install.packages("plot3D")
################################################################################
# using downloaded packages
################################################################################
library("plot3D")
################################################################################
# using lib
################################################################################
source("lib.R")
################################################################################
# defining df and variables
################################################################################
df <- iris_df()
df.col <- iris_color_index()
################################################################################
# create the diffusion matrix from a normalized df
################################################################################
eigen <- eigen_matrix(
as.matrix(
x = dist(
x = apply(
X = df,
MARGIN = 2,
FUN = normalize_column
)
)
)
)
################################################################################
# saving the eigenvectors plot by: defining the filename, ploting and saving
################################################################################
par(mfrow=c(1,2))
plot(
x = eigen$vectors[,2],
y = eigen$vectors[,3],
col = df.col,
pch = 16,
xlab = "",
ylab = ""
)
scatter3D(
x = eigen$vectors[,2],
y = eigen$vectors[,3],
z = eigen$vectors[,4],
colvar = NULL,
col = df.col,
pch = 16,
theta = 45,
phi = 45
)
legend(
x = 'bottomleft',
legend = unique(df.col),
col = 1:length(df.col),
pch = 16
)
################################################################################
# downloading packages
################################################################################
# install.packages("plot3D")
################################################################################
# using downloaded packages
################################################################################
library("plot3D")
################################################################################
# using lib
################################################################################
source("lib.R")
################################################################################
# defining df and variables
################################################################################
df <- iris_df()
df.col <- iris_color_index()
################################################################################
# create the diffusion matrix from a normalized df
################################################################################
eigen <- eigen_matrix(
as.matrix(
x = dist(
x = apply(
X = df,
MARGIN = 2,
FUN = normalize_column
)
)
)
)
################################################################################
# saving the eigenvectors plot by: defining the filename, ploting and saving
################################################################################
par(mfrow=c(1,2))
plot(
x = eigen$vectors[,2],
y = eigen$vectors[,3],
col = df.col,
pch = 16,
xlab = "",
ylab = ""
)
scatter3D(
x = eigen$vectors[,2],
y = eigen$vectors[,3],
z = eigen$vectors[,4],
colvar = NULL,
col = df.col,
pch = 16,
theta = 45,
phi = 45
)
legend(
x = 'bottomleft',
legend = unique(df.col),
col = 1:length(df.col),
pch = 16
)
# install.packages("infotheo")
################################################################################
# using lib
################################################################################
source("lib.R")
library(ggplot2)
library(infotheo)
################################################################################
# defining df and variables
################################################################################
df <- iris_df()
df.col <- iris_color_index()
################################################################################
# create the diffusion matrix from a normalized df
################################################################################
eigen <- eigen_matrix(
as.matrix(
x = dist(
data.frame(
apply(
X = df,
MARGIN = 2,
FUN = normalize_column
)
)
)
)
)
################################################################################
# testing the quality of the generated cluster with the NMI
################################################################################
x = kmeans(eigen$vectors[, 2], 3)$cluster
y = iris$Species
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:3], 3)$cluster
y = iris$Species
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:4], 3)$cluster
y = iris$Species
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(iris[, 1:4], 3)$cluster
y = iris$Species
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
par(mfrow=c(1,2))
plot(eigen$vectors[, 2])
plot(eigen$vectors[, 2:3])
setwd("~/Ãrea de Trabalho/projects/diffusion-map")
# install.packages("infotheo")
################################################################################
# using lib
################################################################################
source("lib.R")
library(ggplot2)
library(infotheo)
library(plot3D)
################################################################################
# defining df and variables
################################################################################
file <- read.table("datasets/oc_12_5000_4000_4.0_p019_0950_1.eigen.csv")
df <- gen_df(file)
df.col <- gen_color_index(file)
################################################################################
# testing the quality of the generated cluster with the NMI
################################################################################
x = kmeans(eigen$vectors[, 2], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:3], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(iris[, 1:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
file <- read.table("datasets/oc_12_5000_4000_4.0_p019_0950_1.eigen.csv")
View(df)
file <- read.table("datasets/oc_12_5000_4000_4.0_p019_0950_1.eigen.csv")
df <- gen_df(file)
df.col <- gen_color_index(file)
x = kmeans(eigen$vectors[, 2], 3)$cluster
x = kmeans(df[, 2], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
mutinformation(x,y)
x = kmeans(df[, 2], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
mutinformation(x,y)
mutinformation(x,y)
x = kmeans(df[, 2], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2:3], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2:4], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = df[, 2]
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
mutinformation(x,y)
((entropy(x) + entropy(y))/2)
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2:3], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
mutinformation(x,y)
((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2:4], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2:3], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 2:4], 2)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(df[, 1:4], 2)$cluster
y = df.col
mutinformation(x,y)
((entropy(x) + entropy(y))/2)
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
df <- stars_df(file)
df.col <- stars_color_index(file)
df <- iris_df(file)
df <- iris_df()
# install.packages("infotheo")
################################################################################
# using lib
################################################################################
source("lib.R")
library(ggplot2)
library(infotheo)
library(plot3D)
################################################################################
# defining df and variables
################################################################################
df <- iris_df()
df.col <- iris_color_index()
################################################################################
# create the diffusion matrix from a normalized df
################################################################################
eigen <- eigen_matrix(
as.matrix(
x = dist(
data.frame(
apply(
X = df,
MARGIN = 2,
FUN = normalize_column
)
)
)
)
)
################################################################################
# testing the quality of the generated cluster with the NMI
################################################################################
x = kmeans(eigen$vectors[, 2], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:3], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(iris[, 1:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
# install.packages("infotheo")
################################################################################
# using lib
################################################################################
source("lib.R")
library(ggplot2)
library(infotheo)
library(plot3D)
################################################################################
# defining df and variables
################################################################################
df <- iris_df()
df.col <- iris_color_index()
################################################################################
# create the diffusion matrix from a normalized df
################################################################################
eigen <- eigen_matrix(
as.matrix(
x = dist(
data.frame(
apply(
X = df,
MARGIN = 2,
FUN = normalize_column
)
)
)
)
)
################################################################################
# testing the quality of the generated cluster with the NMI
################################################################################
x = kmeans(eigen$vectors[, 2], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:3], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(iris[, 1:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
# install.packages("infotheo")
################################################################################
# using lib
################################################################################
source("lib.R")
library(ggplot2)
library(infotheo)
library(plot3D)
################################################################################
# defining df and variables
################################################################################
df <- iris_df()
df.col <- iris_color_index()
################################################################################
# create the diffusion matrix from a normalized df
################################################################################
eigen <- eigen_matrix(
as.matrix(
x = dist(
data.frame(
apply(
X = df,
MARGIN = 2,
FUN = normalize_column
)
)
)
)
)
################################################################################
# testing the quality of the generated cluster with the NMI
################################################################################
x = kmeans(eigen$vectors[, 2], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:3], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(eigen$vectors[, 2:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
x = kmeans(iris[, 1:4], 3)$cluster
y = df.col
mutinformation(x,y)/((entropy(x) + entropy(y))/2)
